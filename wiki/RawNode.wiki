#summary How the data will be organized on media
#labels Phase-Design

= Design =

{{{
struct ash_raw_node {
	__u16	magic;	// contains ASH_MAGIC for valid nodes
	__u8	type;	// node type
	__u8	tcomp;	// compression type
	__u64	size;	// total size in bytes
	__u64	next;	// offset in bytes for the next node
	void*	data;	// node's data
 };
 
 // defines for node types
 #define ASH_NODE_HEAD	1
 #define ASH_NODE_DATA	2
 #define ASH_NODE_END	3
 
 // defines for compression types
 #define ASH_COMP_NONE	1
 #define ASH_COMP_ZIP	2
}}}

The starting idea is to organize the data around by using nodes in a linked list. This allows for a good way to split files around, in case the space is fragmented (and will also lead to annoying 1 sector size fragments in time, we think) so we are not sure if it's a very good idea.

Basically, these nodes should be a linked list, with the superblock's firstnode pointing to the offset of the first ash_raw_node. Given that physical device's sector size is 512 bytes, there is a question whether we will have ash_raw_nodes start only from beginning of a sector, or be able to start anywhere inside a sector. They surely CAN spawn data on more than a sector, so it's a sure thing that generating files will lead to an ash_raw_node ending in the middle of a certain sector, leaving the rest of the space available for interpretation.

There are 2 ways to handle this:
 # leave the sector empty to the end and start next raw node from the beginning of the next sector. This will lead to wasted space, such as writing 100 files of 200 bytes, and having in fact 512 * 100 bytes less space available :P, on rough estimate, which is DOUBLE what the files occupy. This is obviously a bad idea.
 
 # start a new raw node right from the end of another, next time we need space. This calls for linked lists, but also calls for storing offsets to nodes as "pointers" to them, which can be... maybe performance consumming. Not sure at this stage.

Having the raw nodes one after the other poses a new problem: finding a certain file without help of RAM's cached structures will take O(n) due to having to traverse all the raw nodes, which is a bit of a performance problem, we think.

Going to have to work more on this aspect, before even starting implementation.

Gabriel.